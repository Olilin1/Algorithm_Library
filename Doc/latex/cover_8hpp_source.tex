\doxysection{cover.\+hpp}
\hypertarget{cover_8hpp_source}{}\label{cover_8hpp_source}\index{Misc/Interval Cover/cover.hpp@{Misc/Interval Cover/cover.hpp}}
\mbox{\hyperlink{cover_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{/*}}
\DoxyCodeLine{00002\ \textcolor{comment}{\ \ \ \ AUTHOR:\ Oliver\ Lindgren}}
\DoxyCodeLine{00003\ \textcolor{comment}{*/}}
\DoxyCodeLine{00004\ }
\DoxyCodeLine{00005\ \textcolor{preprocessor}{\#ifndef\ COVER\_HPP}}
\DoxyCodeLine{00006\ \textcolor{preprocessor}{\#define\ COVER\_HPP}}
\DoxyCodeLine{00007\ }
\DoxyCodeLine{00008\ \textcolor{preprocessor}{\#include<vector>}}
\DoxyCodeLine{00009\ \textcolor{preprocessor}{\#include<utility>}}
\DoxyCodeLine{00010\ \textcolor{preprocessor}{\#include<algorithm>}}
\DoxyCodeLine{00011\ }
\DoxyCodeLine{00012\ \textcolor{comment}{/*}}
\DoxyCodeLine{00013\ \textcolor{comment}{Takes\ an\ interval\ to\ be\ covered\ as\ a\ pair\ of\ doubles,\ with\ the\ first\ pair\ value\ being\ the\ left\ bound\ of\ the\ interval,}}
\DoxyCodeLine{00014\ \textcolor{comment}{and\ the\ second\ pair\ value\ being\ the\ right\ bound\ of\ the\ interval.\ It\ also\ takes\ a\ list\ of\ intervals\ that\ should\ be\ used\ to}}
\DoxyCodeLine{00015\ \textcolor{comment}{try\ and\ cover\ this\ interval.\ Returns\ a\ vector\ containing\ the\ indices\ in\ the\ intervals\ vector\ relating\ to\ the\ intervals\ that\ need\ to\ be\ used.}}
\DoxyCodeLine{00016\ \textcolor{comment}{If\ it\ is\ not\ possible\ to\ cover\ interval\ then\ an\ empty\ vector\ is\ returned.}}
\DoxyCodeLine{00017\ \textcolor{comment}{O(n\ log(n))\ -\/\ where\ n\ is\ the\ size\ of\ the\ intervals\ vector.}}
\DoxyCodeLine{00018\ \textcolor{comment}{}}
\DoxyCodeLine{00019\ \textcolor{comment}{TODO:\ Template\ it\ \&\ convert\ intervals\ to\ be\ range\ based.}}
\DoxyCodeLine{00020\ \textcolor{comment}{*/}}
\DoxyCodeLine{00021\ }
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ std::vector<size\_t>\ \mbox{\hyperlink{cover_8hpp_a42a86515a6d6f36180000e4a78a1a1cb}{cover}}(\textcolor{keyword}{const}\ std::pair<double,\ double>\ interval,\ \textcolor{keyword}{const}\ std::vector<std::pair<double,\ double>>\&\ intervals)\{}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \ \ \ \ \textcolor{comment}{//Tripple\ will\ be\ used\ later\ to\ store\ intervals\ (first,\ second)\ as\ well\ as\ their\ index\ in\ the\ originial\ intervals\ array.}}
\DoxyCodeLine{00026\ \ \ \ \ \textcolor{keyword}{struct\ }Tripple\{}
\DoxyCodeLine{00027\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{double}\ first,\ second;}
\DoxyCodeLine{00028\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ third;}
\DoxyCodeLine{00029\ \ \ \ \ \};}
\DoxyCodeLine{00030\ }
\DoxyCodeLine{00031\ \ \ \ \ \textcolor{keywordtype}{double}\ l\ =\ interval.first,\ r\ =\ interval.second;}
\DoxyCodeLine{00032\ \ \ \ \ \textcolor{keywordflow}{if}(l\ ==\ r)\{\ \textcolor{comment}{//If\ the\ interval\ is\ a\ single\ point\ then\ deal\ with\ that\ case}}
\DoxyCodeLine{00033\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ intervals.size();\ i++)\{}
\DoxyCodeLine{00034\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(intervals[i].first\ <=\ l\ \&\&\ intervals[i].second\ >=\ r)\ \textcolor{keywordflow}{return}\ \{i\};}
\DoxyCodeLine{00035\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00036\ }
\DoxyCodeLine{00037\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00038\ \ \ \ \ \}\ }
\DoxyCodeLine{00039\ }
\DoxyCodeLine{00040\ }
\DoxyCodeLine{00041\ \ \ \ \ \textcolor{comment}{//Make\ a\ copy\ of\ intervals\ (where\ the\ original\ index\ is\ included\ also)\ and\ sort\ it\ based\ on\ where\ the\ intervals\ begin.\ This\ will\ be\ necessary\ to\ use\ the\ greedy\ algorithm\ effectively.}}
\DoxyCodeLine{00042\ \ \ \ \ std::vector<Tripple>\ intervalsCopy;}
\DoxyCodeLine{00043\ }
\DoxyCodeLine{00044\ \ \ \ \ intervalsCopy.reserve(intervals.size());}
\DoxyCodeLine{00045\ }
\DoxyCodeLine{00046\ \ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ intervals.size();\ i++)\{}
\DoxyCodeLine{00047\ \ \ \ \ \ \ \ \ intervalsCopy.push\_back(\{intervals[i].first,\ intervals[i].second,\ i\});}
\DoxyCodeLine{00048\ \ \ \ \ \}}
\DoxyCodeLine{00049\ }
\DoxyCodeLine{00050\ \ \ \ \ std::sort(intervalsCopy.begin(),\ intervalsCopy.end(),\ [](Tripple\&\ a,\ Tripple\&\ b)\{}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ return\ a.first\ <\ b.first;}
\DoxyCodeLine{00052\ \ \ \ \ \});}
\DoxyCodeLine{00053\ }
\DoxyCodeLine{00054\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ index\ =\ 0;}
\DoxyCodeLine{00055\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ bestIndex\ =\ 0;}
\DoxyCodeLine{00056\ \ \ \ \ \textcolor{keywordtype}{double}\ reach\ =\ l;}
\DoxyCodeLine{00057\ }
\DoxyCodeLine{00058\ \ \ \ \ std::vector<size\_t>\ solution;}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \ \ }
\DoxyCodeLine{00061\ \ \ \ \ \textcolor{keywordflow}{while}(l\ <\ r)\{}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}(index\ <\ intervalsCopy.size()\ \&\&\ intervalsCopy[index].first\ <=\ l)\{}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//Find\ whatever\ interval\ that\ begins\ before\ current\ l\ that\ reaches\ the\ furthest.}}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(intervalsCopy[index].second\ >\ reach)\{}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bestIndex\ =\ intervalsCopy[index].third;}
\DoxyCodeLine{00067\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ reach\ =\ intervalsCopy[index].second;}
\DoxyCodeLine{00068\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00069\ \ \ \ \ \ \ \ \ \ \ \ \ index++;}
\DoxyCodeLine{00070\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00071\ }
\DoxyCodeLine{00072\ \ \ \ \ \ \ \ \ \textcolor{comment}{//If\ we\ couldn't\ extend\ the\ interval\ we\ are\ working\ on\ then\ return\ empty\ vector.}}
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(reach\ ==\ l)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00074\ }
\DoxyCodeLine{00075\ \ \ \ \ \ \ \ \ l\ =\ reach;}
\DoxyCodeLine{00076\ \ \ \ \ \ \ \ \ solution.push\_back(bestIndex);}
\DoxyCodeLine{00077\ \ \ \ \ \}}
\DoxyCodeLine{00078\ }
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordflow}{return}\ solution;}
\DoxyCodeLine{00080\ \}}
\DoxyCodeLine{00081\ }
\DoxyCodeLine{00082\ }
\DoxyCodeLine{00083\ \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
